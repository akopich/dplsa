package ru.ispras.modis.topicmodels.topicmodels

import org.apache.spark.broadcast.Broadcast


/**
 * Created with IntelliJ IDEA.
 * User: padre
 * Date: 28.08.13
 * Time: 13:38
 * To change this template use File | Settings | File Templates.
 */
/**
 * contains number of words, generated by topic, and words from background.
 * @param topicWords topics counter
 * @param backgroundWords background topics counter
 * @param alphabetSize
 */
class GlobalParameters(val topicWords: Array[Array[Float]], val backgroundWords: Array[Float], alphabetSize : Int) extends Serializable {

  /**
   * merges two GlobalParameters into a single one
   * @param that other GlobalParameters
   * @return GlobalParameters
   */
    def +(that: GlobalParameters) = {
        topicWords.zip(that.topicWords).foreach {
            case (thisOne, otherOne) => 
                (0 until alphabetSize).foreach(i => thisOne(i) += otherOne(i))
        }

      (0 until alphabetSize).foreach(i => backgroundWords(i) += that.backgroundWords(i))

        new GlobalParameters(topicWords, backgroundWords, alphabetSize)
    }

  /**
   * calculates and add local parameters to global parameters
   * @param that DocumentParameters.
   * @param topics broadcasted words by topics distribution
   * @param background words by background distribution
   * @param eps weight of noise
   * @param gamma weight of background
   * @param alphabetSize number of unique words
   * @return GlobalParameters
   */
    def add(that: DocumentParameters, topics: Broadcast[Array[Array[Float]]], background: Array[Float], eps: Float, gamma: Float, alphabetSize: Int) = {

        val (wordsFromTopic, wordsFromBackground) = that.wordsFromTopicsAndWordsFromBackground(topics, background, eps: Float, gamma)

        wordsFromTopic.zip(topicWords).foreach {
            case (topic, words) => topic.activeIterator.foreach {
                case (word, num) => words(word) += num
            }
        }

        wordsFromBackground.activeIterator.foreach {
            case (key, value) => backgroundWords(key) += value
        }

        this
    }
}

/**
 * companion object of class GlobalParameters
 */
object GlobalParameters {
  /**
   * construct new GlobalParameters
   * @param topicNum number of topics
   * @param alphabetSize number of unique words
   * @return  new GlobalParameters
   */
    def apply(topicNum: Int, alphabetSize: Int) = {
        val topicWords = (0 until topicNum).map(i => new Array[Float](alphabetSize)).toArray
        val backgroundWords = new Array[Float](alphabetSize)
        new GlobalParameters(topicWords, backgroundWords, alphabetSize)
    }
}